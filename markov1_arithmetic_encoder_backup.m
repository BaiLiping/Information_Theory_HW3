function encoded_bits = markov1_arithmetic_encoder_backup(input_stream, alpha, beta, N, P)
    
    % Peudocode
    
    % let p0 denote the P-bit integer which is used to represent the probability fX (x = 0):
    % p0 = ⌊2P fX (x = 0)⌋
    % when the input stream is generated by Markov1 process. The symbol probability has to be replaced by transition probabilities.

    % Initialize C=0, A=2^N, r=-1, b=0
    % FOR each n=0,1,... DO
    %     T = A * p0
    %     IF xn = 1
    %         C = C + T
    %         T = bitshift(A,P) - T;
    %     END
    %     IF C >= 2^(N+P)
    %         C = bitand(C, mask)
    %         % propagate carry
    %         emit-bit(1)
    %         IF r>0
    %             execute r-1 times, emit-bit(0)
    %             SET r=0
    %         ELSE
    %             SET r=-1
    %         END
    %     END
    %     WHILE T < 2^(N+P-1) 
    %         % renormalize once
    %         b = b + 1
    %         T = 2 * T
    %         C = 2 * C
    %     IF C >= 2^(N+P)
    %         C = bitand(C, mask)
    %         % overflow of C
    %         IF r<0
    %             emit-bit(1)
    %         ELSE
    %             r = r + 1
    %         END
    %     ELSE
    %         % no overflow of C
    %         IF r>=0
    %             emit-bit(0)
    %             execute r times, emit-bit(1)
    %         END
    %         SET r = 0
    %     END
    %     END (while)
    %     SET A = floor(T / 2^P)
    %     END (for)
    %     IF r>= 0
    %     emit-bit(0)
    %     execute r times, emit-bit(1)
    %     END
    %     emit N+P bits of register C
    %     
    %     
    
    
    
    
    
    
    
    % Initialization
    C = 0; 
    A = 2^N; 
    r = -1; 
    b = 0;   
    encoded_bits = []; 
    mask = 2^(N+P) - 1; 
    scaling_factor = 290; 
    alpha_scaled = round(alpha * scaling_factor); 
    beta_scaled = round(beta * scaling_factor);

    for n = 1:length(input_stream)
        xn = input_stream(n); % Get the current bit to be encoded
       
        if n == 1
            p0_scaled = 0.5;
        else
            if input_stream(n-1) == '0'
                if xn == '0' 
                    p0_scaled = (scaling_factor - alpha_scaled); 
                else 
                    p0_scaled = alpha_scaled;
                end
            else
                if xn == '0' 
                    p0_scaled = beta_scaled;
                else 
                    p0_scaled = (scaling_factor - beta_scaled); 
                end
            end
        end
    
        T = A * p0_scaled; % Multiply A by the probability p0
    
        if xn == '1' 
            C = C + T; % Increment C by T if current bit is 1
        end
        % Equivalent to T = 2^P * A - T
        T = bitshift(A, P) - T; 
        
        % Check for overflow in register C and adjust if necessary
        if C >= 2^(N+P)
            % Modulo operation to keep N+P bits
            C = bitand(C, mask); 
            % carry bit
            encoded_bits = [encoded_bits, 1]; 
            if r > 0
                encoded_bits = [encoded_bits, zeros(1, r-1)];
                r = 0; 
            else
                r = -1;
            end
        end
    
        % Renormalization loop to ensure T has enough significant bits
        while T < 2^(N+P-1)
            T = 2 * T; % Double T
            C = bitshift(C, 1); % Left shift C to add a zero bit at the end
            
            % Check for overflow in C after renormalization
            if C >= 2^(N+P)
                C = bitand(C, mask); % Modulo operation to keep N+P bits
                if r < 0
                    encoded_bits = [encoded_bits, 1]; % Emit bit for carry
                else
                    r = r + 1; % Increment r
                end
            else
                % If there is no overflow
                if r >= 0
                    encoded_bits = [encoded_bits, 0]; % Emit a 0 bit
                    encoded_bits = [encoded_bits, ones(1, r)]; % Emit r 1s
                end
                r = 0; % Reset r
            end
        end
        A = floor(T / 2^P); % Adjust A based on the new T value
    end
    
    % Finalize encoding by flushing the remaining bits of register C
    if r >= 0
        encoded_bits = [encoded_bits, 0]; % Emit a 0 bit
        encoded_bits = [encoded_bits, ones(1, r)]; % Emit r 1s
    end
    
    % Convert C to binary and append it to the bitstream
    final_bits = dec2bin(bitand(C, mask), N+P) - '0'; % Convert C to binary with N+P bits
    encoded_bits = [encoded_bits, final_bits]; % Append final bits to output
end
